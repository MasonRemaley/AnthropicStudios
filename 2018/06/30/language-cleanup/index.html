<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Scripting Language Cleanup | Anthropic Studios</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Scripting Language Cleanup" />
<meta name="author" content="mason" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="When we built the original Monsters and Sprites demo, we only had 9 days to get it working before the Playcrafting expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous engine/language features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it. We’ve made a few game updates since then (we now have sound!), but this post is specifically going to explore some language updates I’ve made. I made a bunch of smaller changes that I’m going to just gloss over here: Adding new compiler warnings Fixing a parser error in compound assignments for structs (e.g. x.y += 2) Fixing bugs in the type checker Supporting a similar struct initializer shorthand to what Rust allows (e.g. @Vec2 { x: x, y: y } can now be written as @Vec2 { x, y }) And some slightly bigger ones I’ll write about more in depth." />
<meta property="og:description" content="When we built the original Monsters and Sprites demo, we only had 9 days to get it working before the Playcrafting expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous engine/language features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it. We’ve made a few game updates since then (we now have sound!), but this post is specifically going to explore some language updates I’ve made. I made a bunch of smaller changes that I’m going to just gloss over here: Adding new compiler warnings Fixing a parser error in compound assignments for structs (e.g. x.y += 2) Fixing bugs in the type checker Supporting a similar struct initializer shorthand to what Rust allows (e.g. @Vec2 { x: x, y: y } can now be written as @Vec2 { x, y }) And some slightly bigger ones I’ll write about more in depth." />
<link rel="canonical" href="https://www.anthropicstudios.com/2018/06/30/language-cleanup/" />
<meta property="og:url" content="https://www.anthropicstudios.com/2018/06/30/language-cleanup/" />
<meta property="og:site_name" content="Anthropic Studios" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-30T00:00:00-04:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Scripting Language Cleanup","dateModified":"2018-06-30T00:00:00-04:00","url":"https://www.anthropicstudios.com/2018/06/30/language-cleanup/","datePublished":"2018-06-30T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.anthropicstudios.com/2018/06/30/language-cleanup/"},"author":{"@type":"Person","name":"mason"},"description":"When we built the original Monsters and Sprites demo, we only had 9 days to get it working before the Playcrafting expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous engine/language features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it. We’ve made a few game updates since then (we now have sound!), but this post is specifically going to explore some language updates I’ve made. I made a bunch of smaller changes that I’m going to just gloss over here: Adding new compiler warnings Fixing a parser error in compound assignments for structs (e.g. x.y += 2) Fixing bugs in the type checker Supporting a similar struct initializer shorthand to what Rust allows (e.g. @Vec2 { x: x, y: y } can now be written as @Vec2 { x, y }) And some slightly bigger ones I’ll write about more in depth.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.anthropicstudios.com/feed.xml" title="Anthropic Studios" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/"><img src="/assets/logo.png" height="50px"/> Anthropic Studios</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/">Blog</a><a class="page-link" href="/press/">Press Kit</a><a class="page-link" href="/contact/">Contact Us</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Scripting Language Cleanup</h1>
    
    <p class="post-meta">
  <time class="dt-published" datetime="2018-06-30T00:00:00-04:00" itemprop="datePublished">Jun 30, 2018
  </time>
    • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name"><a href="//twitter.com/MasonRemaley">Mason Remaley</a></span></span>&nbsp;•
  
    <a class="tag" href="/blog/tags/way-of-rhea">way-of-rhea</a>
  
    <a class="tag" href="/blog/tags/tech">tech</a>
  
</p>

  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>When we built the original <a href="/monsters-and-sprites">Monsters and Sprites</a> demo, we only had 9 days to get it working before the <a href="https://playcrafting.com/" target="_blank">Playcrafting</a> expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous <a href="https://masonremaley.com/projects/game-engine/">engine</a>/<a href="https://masonremaley.com/projects/scripting-language/">language</a> features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it.</p>

<p>We’ve made a few game updates since then (<a href="https://twitter.com/AnthropicSt/status/1010568311690743808">we now have sound!</a>), but this post is specifically going to explore some language updates I’ve made.</p>

<p>I made a bunch of smaller changes that I’m going to just gloss over here:</p>

<ul>
  <li>Adding new compiler warnings</li>
  <li>Fixing a parser error in compound assignments for structs (e.g. <code class="language-plaintext highlighter-rouge">x.y += 2</code>)</li>
  <li>Fixing bugs in the type checker</li>
  <li>Supporting a similar struct initializer shorthand to what Rust allows (e.g. <code class="language-plaintext highlighter-rouge">@Vec2 { x: x, y: y }</code> can now be written as <code class="language-plaintext highlighter-rouge">@Vec2 { x, y }</code>)</li>
</ul>

<p>And some slightly bigger ones I’ll write about more in depth.</p>

<!--more-->

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="numeric-types">Numeric Types</h1>

<p>My initial pass at numeric types for the language involved using big integers for all integer types, and ratios of big integers for decimals. Under the hood these were just types exported by <a href="https://github.com/rust-num/num" target="_blank">rust-num</a>. In practice, this resulted in a lot more trouble than it was worth:</p>

<ul>
  <li>The engine almost always had to convert them back to normal number types before passing them to (for example) OpenGL anyway</li>
  <li>Ratios don’t work well for physics as the numerators/denominators get very large making it unclear how to ideally convert them back to floats when you inevitably need to</li>
  <li>The semantics are arguably more confusing and subtle: I can set up fixed size integers to crash when they get too large, big ints just get slower.</li>
</ul>

<p>So this change was pretty straightforward, I actually made parts of it during the week I was working on the demo: <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">ratio</code> are now replaced with <code class="language-plaintext highlighter-rouge">i8</code>, <code class="language-plaintext highlighter-rouge">i16</code>, <code class="language-plaintext highlighter-rouge">i32</code>, <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">isize</code>, <code class="language-plaintext highlighter-rouge">u8</code>, <code class="language-plaintext highlighter-rouge">u16</code>, <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">u64</code>, <code class="language-plaintext highlighter-rouge">usize</code>, <code class="language-plaintext highlighter-rouge">f32</code>, and <code class="language-plaintext highlighter-rouge">f64</code>. If I ever feel like I really want the other types I can add them as additional options.</p>

<p>The biggest open question here is how to decide what type a literal is. Previously it was easy: If your number had a decimal, it was a <code class="language-plaintext highlighter-rouge">ratio</code>, otherwise it was an <code class="language-plaintext highlighter-rouge">int</code>. Now it’s not so clear. To start with I’ve just set <code class="language-plaintext highlighter-rouge">i32</code>/<code class="language-plaintext highlighter-rouge">f32</code> as the defaults and required a postfix (e.g. <code class="language-plaintext highlighter-rouge">10u8</code>) for all other types, but I’m considering some kind of type inference here to make this less verbose.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="format-strings">Format Strings</h1>

<p>Up until this point, the language had no good way to handle <code class="language-plaintext highlighter-rouge">println</code> because I wanted to wait until I came up with a decent solution to make a decision on this, so I was stuck doing a lot of this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">println</span><span class="p">(</span><span class="s">"High Score: "</span> <span class="o">+</span> <span class="p">(</span><span class="n">score</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="k">as</span> <span class="n">string</span> <span class="o">+</span> <span class="s">"!"</span><span class="p">);</span>
</code></pre></div></div>

<p>This is inefficient since currently there’s no optimization preventing it from reallocating after every addition, but more importantly, it’s difficult to read and write. Many languages have some sort of special function type that takes a variable number of parameters to solve this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"High Score: %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">score</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>

<p>I’m hesitant to add support for that to this language so early though as the only thing I see myself using it for right now is string formatting. If I’m going to add something like this I want more use cases to evaluate it against. At the same time I found myself writing a lot of print statements when building the Monsters and Sprites demo. So instead of creating a whole new function type, I decided just to add a format string syntax:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">println</span><span class="p">(</span><span class="n">f</span><span class="s">"High Score: {score * 100}!"</span><span class="p">);</span>
</code></pre></div></div>

<p>Breaking this down, <code class="language-plaintext highlighter-rouge">println</code> is just a normal function of type <code class="language-plaintext highlighter-rouge">fn(string)</code> like before, but is being called here with a “format string”–that’s where the magic is. Whenever you see a string prefixed by <code class="language-plaintext highlighter-rouge">f"</code>, the contents are interpolated. So for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ let name = "world"
$ f"Hello, {name!}"
"Hello, world!"
</code></pre></div></div>

<p>This syntax was (roughly) taken from Python3.</p>

<p>The type checker/codegen implementation was pretty easy here, I just check that every format arg can be casted to a string, and then in codegen do the cast if necessary and emit a <code class="language-plaintext highlighter-rouge">Concat</code> bytecode instruction which I’ve implemented to allocate a string with the capacity equal to that of the sum of the lengths of each piece of the string, and then slot in the pieces. Surprisingly the <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank">lexing</a>/<a href="https://en.wikipedia.org/wiki/Parsing" target="_blank">parsing</a> for once turned out to be the hard part.</p>

<p>For those unfamiliar, compilers normally break down source code into “tokens” like <code class="language-plaintext highlighter-rouge">Plus</code>, <code class="language-plaintext highlighter-rouge">Minus</code>, or <code class="language-plaintext highlighter-rouge">Identifier(score)</code> in a phase called lexing before the parser converts the tokens into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>, usually using <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank">recursive descent</a>. Normally lexing and parsing are completely separably.</p>

<p>The problem I ran into was that format strings can contain arbitrary expressions inside of them that should be evaluated as normal code if they’re between braces, which means the lexer needs to know when to stop parsing strings and start parsing expressions, and also when the expression is finished. However, the lexer by definition doesn’t know when the expression is finished–only the parser does.</p>

<p>To solve this problem, I decided to change the pattern slightly–the parser now handles strings instead of the lexer. When the parser hits a quote, it switches the lexer into a mode where it just reads the characters directly without converting them into tokens. When parsing format strings, the parser just switches modes whenever it enters/exists a format arg. This sounds a little odd at first when you’re used to the normal pattern, but it ends up being really elegant.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="imports">Imports</h1>

<p>The language doesn’t yet support methods. I’m not really a fan of the way classes/methods are implemented in most languages, so I’m holding off on making any decisions here until I have a better idea of how I want things to work. It turns out that so far in practice…not having methods has been fine. I’ve just put structs that I’d like to treat as classes in their own files and put free functions with parameters named
<code class="language-plaintext highlighter-rouge">self</code> in the same namespace:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// player.welp</span>

<span class="n">import</span> <span class="n">math</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Ball</span> <span class="p">{</span>
    <span class="n">position</span><span class="p">:</span> <span class="o">@</span><span class="nn">math</span><span class="p">::</span><span class="n">Vec2</span><span class="p">,</span>
    <span class="n">velocity</span><span class="p">:</span> <span class="o">@</span><span class="nn">math</span><span class="p">::</span><span class="n">Vec2</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="o">@</span><span class="nn">math</span><span class="p">::</span><span class="n">Vec2</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="o">@</span><span class="nn">math</span><span class="p">::</span><span class="n">Vec2</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">@</span><span class="k">mut</span> <span class="n">Ball</span> <span class="p">{</span>
    <span class="o">@</span><span class="k">mut</span> <span class="n">Ball</span> <span class="p">{</span>
        <span class="n">position</span><span class="p">,</span>
        <span class="n">velocity</span><span class="p">:</span> <span class="o">@</span><span class="k">mut</span> <span class="nn">Math</span><span class="p">::</span><span class="n">Vec2</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span> <span class="p">},</span>
        <span class="n">size</span><span class="p">:</span> <span class="o">@</span><span class="k">mut</span> <span class="nn">math</span><span class="p">::</span><span class="n">Vec2</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span> <span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="o">@</span><span class="n">Ball</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// ...</span>
</code></pre></div></div>

<p>The biggest annoyance here is that because each type gets its own namespace, you end up having to say things like <code class="language-plaintext highlighter-rouge">ball::Ball</code> a lot which is silly. This lead me to decid it was time to update how I handle imports a bit: you can now import specific types/statics instead of whole modules, and do so under aliased names to prevent clashes and such.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">ball</span><span class="p">::</span><span class="n">Ball</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">dbg</span><span class="p">::</span><span class="n">println</span> <span class="k">as</span> <span class="k">log</span><span class="p">;</span>
<span class="k">use</span> <span class="n">ball</span> <span class="k">as</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<hr />

<p><br /></p>

<p>With all of these changes, I was able to easily make sure I don’t miss any existing code when updating it to use new features/idioms by just adding new compiler warnings. So, for example, if I had previously written code that looked like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">Vec2</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="p">}</span>
</code></pre></div></div>

<p>I now get some helpful warnings pointing out that there’s now a nicer way to do this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ @Vec2 { x: x, y: y }
warning: redundant field name in initializer, when assigning a field to a
variable of the same name you can simply name the field and give it no explicit
value (use #[allow(redundant_field_name)] to ignore)
  --&gt; input:1:12
  | 
1 | @Vec2 { x: x, y: y }
  |            ^        

warning: redundant field name in initializer, when assigning a field to a
variable of the same name you can simply name the field and give it no explicit
value (use #[allow(redundant_field_name)] to ignore)
  --&gt; input:1:18
  | 
1 | @Vec2 { x: x, y: y }
  |                  ^  
</code></pre></div></div>

<p>For bigger changes, I just have old code error out at compile time if it doesn’t match up with the newer version of the language. I’m my only user at the moment so while versioning is still important, backwards compat isn’t. This is also one of the reasons I’ve held off on making any of these tools public: I want to maintain the ability to make drastic changes without bothering anyone besides myself.</p>

  </div>

  <p>
    Feel free to leave comments on

    
      <a href="https://twitter.com/AnthropicSt/status/1013202971998539776">Twitter,</a>
    
    

    <a href="https://discord.gg/JGeVt5XwPP">Discord,</a> or <a href="mailto:anthropicstudios@gmail.com">send us an email!</a><p>
  </p>

  <div style="">
    <style type="text/css">
      #signup {
        margin-left: auto;
        margin-right: auto;
      }
    </style>
    
<a href="/newsletter/signup/tech" class="signup">
	<span>Newsletter Signup</span>
</a>


  </div>
  <br>

  <div>
    
      <a style="float:left" href="/2018/06/30/artists-alley-1/">&laquo; Artists' Alley #1: Abstract Palettes and Environment</a>
    
    
      <a style="float:right" href="/2018/06/30/arists-alley-2/">Artists' Alley #2: Inspiration and Learning from the Greats &raquo;</a>
    
  </div><a class="u-url" href="/2018/06/30/language-cleanup/" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1" style="width: 100%">
        
        <a class="u-email" href="mailto:anthropicstudios@gmail.com">anthropicstudios@gmail.com</a>
        
      </div>

      <div class="footer-col footer-col-2">
        <p></p>
      </div>

      <div class="footer-col footer-col-3">
        <ul class="social-media-list" style="width:100%; float: right">
  <li><a href="https://discord.gg/JGeVt5XwPP"><img src="https://discord.com/api/guilds/787767251884310548/widget.png?style=shield"/></a></li>
  
  <li><a href="https://www.twitter.com/AnthropicSt"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">@Twitter</span></a></li>
  <li><a href="https://instagram.com/AnthropicStudios"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg> <span class="username">@Instagram</span></a></li>
  

  <li><a href="https://www.facebook.com/AnthropicStudios"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">@Facebook</span></a></li>
</ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
