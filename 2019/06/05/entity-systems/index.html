<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Way of Rhea’s Entity System | Anthropic Studios</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Way of Rhea’s Entity System" />
<meta name="author" content="mason" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I posted this poll on Twitter few weeks ago: Entity systems won by a long shot, so that’s what I’m going to be writing about today. In particular, I’m going to outline the process that lead me to Way of Rhea’s current entity system. Way of Rhea is being built in a custom engine and scripting language written in Rust, but the ideas described should still be applicable elsewhere. Hopefully this writeup will be found helpful, or at least interesting. :) The Ad Hoc Approach Way of Rhea’s initial prototype didn’t have an explicit entity system—I wanted to get something playable on the screen ASAP to validate that the game idea was worth spending time on. Each time I wanted to introduce a new entity type, I just made a new struct, and an ad hoc decision on where to store it. This approach is severely undervalued. Letting yourself be inconsistent during the early stages of a project has two big advantages: It lets you prototype just the thing you’re actually trying to build. It generates a lot of data on what a generic system would actually need to accomplish. It’s hard to build a good cart before you know anything about the horse. :) Some entities like the player were hard coded into the all-encompassing &quot;world&quot; struct, while others were stored in a tile map and exposed to the editor via the pictured GUI. As most entities in the game were fairly independent of each other, this approach served me well for almost a year. As time wore on, though, I had more and more ideas that couldn’t be expressed well in the system I’d built up… Many of the puzzles I wanted to build involved entities being run through some sort of physics simulation, which would have been difficult to add to the existing codebase. It was going to be difficult to add things like physics puzzles to the game if there wasn’t a good way to share data and behavior between entities. This problem seemed chronic enough that it was worth solving the general case." />
<meta property="og:description" content="I posted this poll on Twitter few weeks ago: Entity systems won by a long shot, so that’s what I’m going to be writing about today. In particular, I’m going to outline the process that lead me to Way of Rhea’s current entity system. Way of Rhea is being built in a custom engine and scripting language written in Rust, but the ideas described should still be applicable elsewhere. Hopefully this writeup will be found helpful, or at least interesting. :) The Ad Hoc Approach Way of Rhea’s initial prototype didn’t have an explicit entity system—I wanted to get something playable on the screen ASAP to validate that the game idea was worth spending time on. Each time I wanted to introduce a new entity type, I just made a new struct, and an ad hoc decision on where to store it. This approach is severely undervalued. Letting yourself be inconsistent during the early stages of a project has two big advantages: It lets you prototype just the thing you’re actually trying to build. It generates a lot of data on what a generic system would actually need to accomplish. It’s hard to build a good cart before you know anything about the horse. :) Some entities like the player were hard coded into the all-encompassing &quot;world&quot; struct, while others were stored in a tile map and exposed to the editor via the pictured GUI. As most entities in the game were fairly independent of each other, this approach served me well for almost a year. As time wore on, though, I had more and more ideas that couldn’t be expressed well in the system I’d built up… Many of the puzzles I wanted to build involved entities being run through some sort of physics simulation, which would have been difficult to add to the existing codebase. It was going to be difficult to add things like physics puzzles to the game if there wasn’t a good way to share data and behavior between entities. This problem seemed chronic enough that it was worth solving the general case." />
<link rel="canonical" href="https://www.anthropicstudios.com/2019/06/05/entity-systems/" />
<meta property="og:url" content="https://www.anthropicstudios.com/2019/06/05/entity-systems/" />
<meta property="og:site_name" content="Anthropic Studios" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-05T00:00:00-04:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Way of Rhea’s Entity System","dateModified":"2019-06-05T00:00:00-04:00","url":"https://www.anthropicstudios.com/2019/06/05/entity-systems/","datePublished":"2019-06-05T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.anthropicstudios.com/2019/06/05/entity-systems/"},"author":{"@type":"Person","name":"mason"},"description":"I posted this poll on Twitter few weeks ago: Entity systems won by a long shot, so that’s what I’m going to be writing about today. In particular, I’m going to outline the process that lead me to Way of Rhea’s current entity system. Way of Rhea is being built in a custom engine and scripting language written in Rust, but the ideas described should still be applicable elsewhere. Hopefully this writeup will be found helpful, or at least interesting. :) The Ad Hoc Approach Way of Rhea’s initial prototype didn’t have an explicit entity system—I wanted to get something playable on the screen ASAP to validate that the game idea was worth spending time on. Each time I wanted to introduce a new entity type, I just made a new struct, and an ad hoc decision on where to store it. This approach is severely undervalued. Letting yourself be inconsistent during the early stages of a project has two big advantages: It lets you prototype just the thing you’re actually trying to build. It generates a lot of data on what a generic system would actually need to accomplish. It’s hard to build a good cart before you know anything about the horse. :) Some entities like the player were hard coded into the all-encompassing &quot;world&quot; struct, while others were stored in a tile map and exposed to the editor via the pictured GUI. As most entities in the game were fairly independent of each other, this approach served me well for almost a year. As time wore on, though, I had more and more ideas that couldn’t be expressed well in the system I’d built up… Many of the puzzles I wanted to build involved entities being run through some sort of physics simulation, which would have been difficult to add to the existing codebase. It was going to be difficult to add things like physics puzzles to the game if there wasn’t a good way to share data and behavior between entities. This problem seemed chronic enough that it was worth solving the general case.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.anthropicstudios.com/feed.xml" title="Anthropic Studios" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/"><img src="/assets/logo.png" height="50px"/> Anthropic Studios</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/">Blog</a><a class="page-link" href="/press/">Press Kit</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Way of Rhea&#39;s Entity System</h1>
    
    <p class="post-meta">
  <time class="dt-published" datetime="2019-06-05T00:00:00-04:00" itemprop="datePublished">Jun 5, 2019
  </time>
    • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name"><a href="//twitter.com/MasonRemaley">Mason Remaley</a></span></span>&nbsp;•
  
    <a class="tag" href="/blog/tags/way-of-rhea">way-of-rhea</a>
  
    <a class="tag" href="/blog/tags/tech">tech</a>
  
</p>

  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I posted <a href="https://twitter.com/masonremaley/status/1135083247598047232">this poll</a> on Twitter few weeks ago:</p>

<figure>
  <a href="https://twitter.com/masonremaley/status/1135083247598047232"><img src="/assets/monsters-and-sprites/entity-systems/poll.png" /></a>
</figure>

<p>Entity systems won by a long shot, so that’s what I’m going to be writing about today.</p>

<p>In particular, I’m going to outline the process that lead me to <a href="https://www.anthropicstudios.com/way-of-rhea">Way of Rhea</a>’s current entity system. <em>Way of Rhea</em> is being built in a <a href="https://www.masonremaley.com/projects/game-engine/">custom engine</a> and <a href="https://www.masonremaley.com/projects/scripting-language/">scripting language</a> written in <a href="https://www.rust-lang.org/">Rust</a>, but the ideas described should still be applicable elsewhere. Hopefully this writeup will be found helpful, or at least interesting. :)</p>

<h2 id="the-ad-hoc-approach">The Ad Hoc Approach</h2>

<p><em>Way of Rhea</em>’s <a href="https://twitter.com/masonremaley/status/988634973245669377">initial prototype</a> didn’t have an explicit entity system—I wanted to get something playable on the screen ASAP to validate that the game idea was worth spending time on. Each time I wanted to introduce a new entity type, I just made a new struct, and an ad hoc decision on where to store it.</p>

<p>This approach is severely undervalued. Letting yourself be inconsistent during the early stages of a project has two big advantages:</p>
<ul>
  <li>It lets you prototype just the thing you’re actually trying to build.</li>
  <li>It generates a lot of data on what a generic system would <em>actually need to accomplish</em>. It’s hard to build a good cart before you know anything about the horse. :)</li>
</ul>

<figure>
  <a href="/assets/monsters-and-sprites/entity-systems/old-editor.jpg"><img src="/assets/monsters-and-sprites/entity-systems/old-editor.jpg" /></a>
  <figcaption>Some entities like the player were hard coded into the all-encompassing "world" struct, while others were stored in a tile map and exposed to the editor via the pictured GUI.</figcaption>
</figure>

<p>As most entities in the game were fairly independent of each other, this approach served me well for almost a year. As time wore on, though, I had more and more ideas that couldn’t be expressed well in the system I’d built up…</p>

<figure>
  <a href="/assets/monsters-and-sprites/entity-systems/physics-small.jpg"><img src="/assets/monsters-and-sprites/entity-systems/physics-small.jpg" /></a>
  <figcaption>Many of the puzzles I wanted to build involved entities being run through some sort of physics simulation, which would have been difficult to add to the existing codebase.</figcaption>
</figure>

<p>It was going to be difficult to add things like physics puzzles to the game if there wasn’t a good way to share data and behavior between entities. This problem seemed chronic enough that it was worth solving the general case.</p>

<!--more-->

<h2 id="common-approaches">Common Approaches</h2>

<p>In my mind, most entity systems fall into one of the following categories:</p>
<ul>
  <li>Decked out versions of the ad hoc approach, well tuned to the needs of a specific game or game type. For lack of a better term I’ll refer to this as the static approach.</li>
  <li>Very dynamic and generic approaches that let you mix and match “components” at will. I’ll refer to this as the dynamic approach.</li>
</ul>

<h3 id="the-static-approach">The Static Approach</h3>
<p>I’ve seen the first approach in a lot of engines that were initially designed for a specific game. If you take the time to understand the somewhat arbitrary metaphysics of one of these systems, they’re generally pretty easy to work with—things you’re likely to want to do are usually directly baked in and have a nice workflow.</p>

<p>On the other hand, if you have a gameplay idea not anticipated by the system, you may have hard time implementing it without some <a href="https://www.geek.com/games/a-train-you-ride-in-fallout-3-is-actually-an-npc-wearing-a-train-hat-1628532/" target="_blank">funny business</a>.</p>

<figure>
  <a href="http://www.insidemacgames.com/features/view.php?ID=312#"><img src="/assets/monsters-and-sprites/entity-systems/dim3-inside-mac-games.jpg" /></a>
  <figcaption>dim3 was the first 3d engine I ever used, described by its creator Brian Barnes as a "game without content". The game had a number of pre-baked object types (lights, scenery items, etc), and the option to introduce new objects via scripts. Screenshot taken from <a href="http://www.insidemacgames.com/features/view.php?ID=312#">Inside Mac Games</a> as I couldn't find a copy of the editor.</figcaption>
</figure>

<h3 id="the-dynamic-approach">The Dynamic Approach</h3>
<p>On the other end of the spectrum is the dynamic approach. When people talk about “entity component systems”, they’re usually talking about something in this category.</p>

<p>This approach has some bold promises: you can mix and match existing pieces like legos, possibly even creating completely new entity types at runtime.</p>

<figure style="width:75%">
  <a href="/assets/monsters-and-sprites/entity-systems/unity.jpg"><img src="/assets/monsters-and-sprites/entity-systems/unity.jpg" /></a>
  <figcaption>In Unity's approach, entities are built up of a large number of components that may or may not depend on each other.</figcaption>
</figure>

<p>This sounds great, but in practice, I’ve seen it have two major problems:</p>
<ul>
  <li>When designing a component, you either anticipate every possible use, or you don’t. If you do you’re likely wasting your time on pairings that will never occur, but if you don’t, you can’t truely mix and match things freely.</li>
  <li>You’ve essentially built a dynamic type system for your game, and taken on all the problems that come with one. For example, in Unity, one component can fail to get data from another at runtime if the component in question isn’t present on the entity or was deleted at runtime—and there’s not always a good way to respond to that failure.</li>
</ul>

<p>This isn’t to say that the dynamic approach is never the way to go—but in practice it does have costs that I don’t often see discussed.</p>

<h2 id="the-best-of-both-worlds">The Best Of Both Worlds</h2>

<p>Neither of these routes felt quite right for <em>Way of Rhea</em>. Between the gameplay not being very dynamic, and <a href="https://www.masonremaley.com/projects/game-engine/">the engine</a>’s support for arbitrary hot swapping, there’s not much need for mixing and matching components at runtime. At the same time, the problem of sharing behavior between entities felt like it was worth solving.</p>

<p>To find a better compromise, we’ll need to break down what we actually want out of the <em>Way of Rhea</em> entity system.</p>

<p>Want:</p>
<ul>
  <li>The ability to have data and/or behavior specific to an entity type</li>
  <li>The ability to have data and/or behavior shared by a set of entity types</li>
</ul>

<p>Would like:</p>
<ul>
  <li>Static knowledge of the fields that will be present on a given entity</li>
</ul>

<p>Don’t need:</p>
<ul>
  <li>We don’t need to create new entity or component types at runtime</li>
</ul>

<p>The single bullet under the “don’t need” category changes things. <strong>Most of these systems get built specifically to allow dynamic changes.</strong> If you’re working on a large team, you don’t want the designers to have to call in a programmer every time they want to try something new, but that isn’t an issue on a small indie team where the designer is the programmer.</p>

<p>Taking all this into account, I came up with a fairly straightforward—but still flexible—approach that satisfies the requirements at hand. I’m going to copy and paste bits and pieces from the <em>Way of Rhea</em> source to explain it. As mentioned previously, the actual game logic is written in <a href="https://www.masonremaley.com/projects/scripting-language/">my scripting language</a>, but the syntax is very similar to <a href="https://www.rust-lang.org/">Rust</a> which my engine, compiler, and VM are written in.</p>

<p>Here’s the current declaration of <code class="language-plaintext highlighter-rouge">Entity</code>:</p>
<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">Entity</span> <span class="p">{</span>
    <span class="nf">Gate</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Gate</span><span class="p">),</span>
    <span class="nf">Elevator</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Elevator</span><span class="p">),</span>
    <span class="nf">Orb</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Orb</span><span class="p">),</span>
    <span class="nf">Stand</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Stand</span><span class="p">),</span>
    <span class="nf">Teleporter</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Teleporter</span><span class="p">),</span>
    <span class="nf">Blocker</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Blocker</span><span class="p">),</span>
    <span class="nf">SpriteSpawnPoint</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">SpawnPoint</span><span class="p">),</span>
    <span class="nf">Sprite</span><span class="p">(</span><span class="o">@</span><span class="k">mut</span> <span class="n">Sprite</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>Similarly to in Rust the <code class="language-plaintext highlighter-rouge">enum</code> keyword in my scripting language represents a <a href="https://en.wikipedia.org/wiki/Sum_type" target="_blank">sum type</a>, equivalent to a tagged union in C.</em></p>

<p>Each entity must be one of these 8 variants. The variants are baked into the system, but it’s trivial to add another and hot swap it in.</p>

<p>Given an arbitrary entity, you can use a match statement—similar to a switch statement in C—to determine its type. For example:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="n">entity</span> <span class="p">{</span>
    <span class="nf">Gate</span><span class="p">(</span><span class="n">gate</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">::</span><span class="k">log</span><span class="p">::</span><span class="nf">info</span><span class="p">(</span><span class="n">f</span><span class="s">"It's a gate: {gate}"</span><span class="p">),</span>
    <span class="nf">Elevator</span><span class="p">(</span><span class="n">elevator</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">::</span><span class="k">log</span><span class="p">::</span><span class="nf">info</span><span class="p">(</span><span class="n">f</span><span class="s">"It's an elevator: {elevator}"</span><span class="p">),</span>
    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">::</span><span class="k">log</span><span class="p">::</span><span class="nf">info</span><span class="p">(</span><span class="s">"It's something else!"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once you’ve matched on an entity and gotten its inner type, you just have an instance of that entity’s struct, and can operate on it directly like you would any struct. For example, you could pass the <code class="language-plaintext highlighter-rouge">gate</code> struct above to this update function:</p>
<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="o">@</span><span class="k">mut</span> <span class="n">Gate</span><span class="p">,</span> <span class="n">entities</span><span class="p">:</span> <span class="o">@</span><span class="n">Entities</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Check if we should be open</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">should_be_open</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">intersecting</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c">// ... (truncated for brevity) ...</span>
    <span class="p">};</span>

    <span class="c">// Apply any necessary state changes</span>
    <span class="k">if</span> <span class="n">should_be_open</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.open</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.open</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="nn">mixer</span><span class="p">::</span><span class="nf">play_sound</span><span class="p">(</span><span class="s">"door open clean.ogg"</span><span class="p">,</span> <span class="n">MAX_VOLUME</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.open</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.open</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="nn">mixer</span><span class="p">::</span><span class="nf">play_sound</span><span class="p">(</span><span class="s">"door close clean.ogg"</span><span class="p">,</span> <span class="n">MAX_VOLUME</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Alright, so nothing particularly novel so far. The trick lies in how we share data and behavior between entity types.</p>

<p><em>Way of Rhea</em> has a lot of color based puzzles in it, and as such most interactive entities in the game have a <code class="language-plaintext highlighter-rouge">color</code> field. If you know the type of an entity you can read that field directly, but what if you want to get the color of an arbitrary entity?</p>

<p>You can probably guess—we just define a function that does the match for us!</p>
<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">color</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="n">Entity</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
        <span class="nf">Gate</span><span class="p">(</span><span class="n">gate</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="nn">Some</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gate</span><span class="py">.color</span><span class="p">),</span>
        <span class="nf">Elevator</span><span class="p">(</span><span class="n">elevator</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="nn">Some</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elevator</span><span class="py">.color</span><span class="p">),</span>
        <span class="nf">Orb</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="nn">Some</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">orb</span><span class="py">.color</span><span class="p">),</span>
        <span class="nf">Sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="nn">Some</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sprite</span><span class="py">.drawable.color</span><span class="p">),</span>
        <span class="nf">SpriteSpawnPoint</span><span class="p">(</span><span class="n">sprite_spawn_point</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="nn">Some</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sprite_spawn_point</span><span class="py">.drawable.color</span><span class="p">),</span>
        <span class="nf">Stand</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span>
        <span class="p">|</span> <span class="nf">Teleporter</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span>
        <span class="p">|</span> <span class="nf">Blocker</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Option</span><span class="p">::</span><span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If the entity has a color, this function returns it. If not, it returns <code class="language-plaintext highlighter-rouge">None</code>. When you don’t know the type of an entity and are okay with the possibility of absence, you read components through one of these functions. When you need a component to be present, you just get a direct reference to the concrete type. If you wanted to hold a reference to any arbitrary entity that must have a color, you could go as far as defining a new enum that can only hold those variants.</p>

<p>The physics simulation, once implemented, will use this pattern as well: when it’s time to update the physics objects, it will be trivial to loop over all the entities and call something like <code class="language-plaintext highlighter-rouge">physics::update(rigid_body)</code> on each entity that has a rigid body.</p>

<figure>
  <a href="/assets/monsters-and-sprites/entity-systems/new-editor.gif"><img src="/assets/monsters-and-sprites/entity-systems/new-editor.gif" /></a>
  <figcaption>The level editor has been updated to take advantage of the entity system. The component getters are used to draw controls for all component types that exist on at least one of the selected entities.</figcaption>
</figure>

<p>There are a few other subtleties around spatial partitioning and serialization, but this is the general idea behind the system. I haven’t lived with it for very long yet, so if I discover anything interesting about it down the line I’ll try to write up another post.</p>

<p>Thanks for reading this far!</p>

  </div>

  <p>
    Feel free to leave comments on

    
      <a href="https://twitter.com/masonremaley/status/1143655586740838400">Twitter,</a>
    
    
      <a href="https://www.reddit.com/r/rust_gamedev/comments/c5lwi5/way_of_rheas_entity_system/">Reddit, </a>
    

    <a href="https://discord.gg/JGeVt5XwPP">Discord,</a> or <a href="mailto:anthropicstudios@gmail.com">send us an email!</a><p>
  </p>

  <div style="">
    <style type="text/css">
      #signup {
        margin-left: auto;
        margin-right: auto;
      }
    </style>
    
<a href="/newsletter/signup/tech" class="signup">
	<span>Newsletter Signup</span>
</a>


  </div>
  <br>

  <div>
    
      <a style="float:left" href="/2018/06/30/arists-alley-2/">&laquo; Artists' Alley #2: Inspiration and Learning from the Greats</a>
    
    
      <a style="float:right" href="/2020/03/30/symmetric-matrices/">Symmetric Matrices & Triangle Numbers &raquo;</a>
    
  </div><a class="u-url" href="/2019/06/05/entity-systems/" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1" style="width: 100%">
        
        <a class="u-email" href="mailto:anthropicstudios@gmail.com">anthropicstudios@gmail.com</a>
        
      </div>

      <div class="footer-col footer-col-2">
        <p></p>
      </div>

      <div class="footer-col footer-col-3">
        <ul class="social-media-list" style="width:100%; float: right">
  <li><a href="https://discord.gg/JGeVt5XwPP"><img src="https://discord.com/api/guilds/787767251884310548/widget.png?style=shield"/></a></li>
  
  <li><a href="https://www.twitter.com/AnthropicSt"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">@Twitter</span></a></li>
  <li><a href="https://instagram.com/AnthropicStudios"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg> <span class="username">@Instagram</span></a></li>
  

  <li><a href="https://www.facebook.com/AnthropicStudios"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">@Facebook</span></a></li>
</ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
